/**
 * Сценарий 2: "Теремок"
 *
 * Стоит в поле теремок, он не низок, не высок. Но места в нем —
 * в обрез, ровно на capacity зверей. Каждый раз, когда зверь заходит в
 * теремок или просто подает голос изнутри, он становится "самым свежим"
 * гостем в памяти теремка. Но если на пороге появляется новый жилец,
 * а мест нет — самому "молчаливому" приходится освобождать место и уходить в лес.
 *
 * Требования:
 * 1. Реализовать хранилище с ограниченной емкостью (capacity).
 * 2. Метод `voice(animal)`: возвращает данные зверя, если он есть в хранилище, иначе null.
 * 3. Метод `settle(animal, data)`: добавляет или обновляет данные зверя.
 * 4. При превышении емкости необходимо удалять элемент, который дольше всего не использовался (не запрашивался через `voice` и не обновлялся через `settle`).
 * 5. Ожидаемая алгоритмическая сложность основных операций — O(1).
 */

export class Teremok<T = any> {
  private capacity: number;

  constructor(capacity: number) {
    this.capacity = capacity;
  }

  // Зверь подает голос — становится "самым свежим" в очереди
  voice(animal: string): T | null {
    // Твоё решение здесь
    return null;
  }

  // Новый зверь хочет поселиться в теремке
  settle(animal: string, data: T): void {
    // Твоё решение здесь
  }
}
